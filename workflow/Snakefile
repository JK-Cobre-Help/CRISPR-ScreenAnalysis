configfile: "config/config.yml"

##################################################################
##                         Author Info                          ##
##################################################################

# Author: Kevin A. Boyd
# Email: kevinboyd76@gmail.com
# GitHub: https://github.com/kevinboyd76
# Date Created: August 8, 2025
# Last Modified: August 12, 2025
# Version: 1.1.0
#
# Description:
# This Snakemake workflow processes raw FASTQ files from a pooled CRISPR screen
# through quality control, FASTQ staging (if needed), count matrix generation
# with MAGeCK, optional design matrix construction, and MAGeCK MLE analysis.
# It is designed to work on both single-end and paired-end data and can process 
# both CRISPR activation and knockout screens. It is built to run on a Slurm-based 
# HPC with module-managed environments.

##################################################################
##                  Specific Steps in Pipeline                  ##
##################################################################

# Steps:
#  1) Quality control using FastQC (per read) and MultiQC (summary report)
#  2) Stage FASTQ files to local storage if `stage_fastqs: true` in config.yml
#  3) Generate count table and count summary with MAGeCK count
#  4) Build design matrix automatically from samples.csv, or use a provided one
#  5) Run MAGeCK MLE to estimate gene-level beta scores (if enabled)
#  6) Generate summary plots from MLE gene summary and count summary (if enabled)
#
# Outputs:
#  • Per-sample FastQC HTML and ZIP files
#  • MultiQC HTML summary report
#  • MAGeCK count output:
#      – counts_prefix.count.txt
#      – counts_prefix.countsummary.txt
#  • Auto-generated design_matrix.txt (if custom not supplied)
#  • MAGeCK MLE output (if enabled):
#      – mle_prefix.gene_summary.txt
#      – Additional MLE files from MAGeCK
#  • Peak summary plot (PNG) from gene_count_summary_plots rule (if enabled)

##################################################################
##                    Define input functions                    ##
##################################################################

import os
import pandas as pd

# read the CSV file and set an index using the values in the "sample" column.
samples_table = pd.read_csv("config/samples.csv").set_index("sample", drop=False)
samples_table["fastq2"] = samples_table["fastq2"].fillna("").astype(str)

# fastq filename input function definition set to Python dictionary
def fq_dict_from_sample(wildcards):
  return {
    "fq1": samples_table.loc[wildcards.sample, "fastq1"],
    "fq2": samples_table.loc[wildcards.sample, "fastq2"]
  }

# Stage FASTQs
STAGE = config["stage_fastqs"]
STAGE_DIR = "results/staged_fastqs"
if STAGE:
    os.makedirs(STAGE_DIR, exist_ok=True)

# Set single end or paired end input for Mageck Count
run_mageck_paired = config["mageck_paired"]

# Set sample labels and counts prefix and attach the directory
SAMPLE_LABELS = ",".join(samples_table["sample"].tolist())
COUNTS_DIR = "results/counts"
os.makedirs(COUNTS_DIR, exist_ok=True)
RAW_COUNTS_NAME = os.path.basename(config["counts_prefix"]).strip()
if not RAW_COUNTS_NAME:
    raise ValueError("config['counts_prefix'] is empty. Provide a short name like 'sample1'.")
COUNTS_PREFIX = os.path.join(COUNTS_DIR, RAW_COUNTS_NAME)

# functions to lookup file paths
def staged_name(sample, read):  # read: "R1" or "R2"
    return os.path.join(STAGE_DIR, f"{sample}_{read}_staged.fastq.gz")

def fq1_src(sample): return samples_table.loc[sample, "fastq1"]
def fq2_src(sample): return samples_table.loc[sample, "fastq2"]

def fq1_used(sample):
    """Path MAGeCK should read for R1 (staged if STAGE=True)."""
    return staged_name(sample, "R1") if STAGE else fq1_src(sample)

def fq2_used(sample):
    """Path MAGeCK should read for R2 (staged if STAGE=True)."""
    return staged_name(sample, "R2") if STAGE else fq2_src(sample)

def mageck_input_files():
    """
    Concrete list of files that mageck_count depends on.
    Ensures staging runs first when STAGE=True.
    """
    if run_mageck_paired:
        return [fq1_used(s) for s in samples_table.index] + \
               [fq2_used(s) for s in samples_table.index]
    else:
        return [fq1_used(s) for s in samples_table.index]

def mageck_fastq_arg_r1():
    """Space-separated list of R1 files for --fastq."""
    return " ".join(fq1_used(s) for s in samples_table.index)

def mageck_fastq_arg_r2():
    """Space-separated list of R2 files for --fastq-2."""
    return " ".join(fq2_used(s) for s in samples_table.index)

# MLE Design
MLE_ENABLED = config["mle_enabled"]

# Combine the name provided in config.yml with the file path and store all MLE outputs in this directory
RAW_MLE_NAME = os.path.basename(config["mle_prefix"]).strip()
if not RAW_MLE_NAME:
    raise ValueError("config['mle_prefix'] is empty. Provide a short name like 'CalabreseA'.")
MLE_DIR = "results/mle"
os.makedirs(MLE_DIR, exist_ok=True)
MLE_PREFIX = os.path.join(MLE_DIR, RAW_MLE_NAME)

# Custom design matrix path from config
CUSTOM_DESIGN = config["custom_design_matrix"].strip()

# Control sgRNAs (optional)
MLE_CTRL = config["mle_control_sgrna"].strip()

# If not provided write an auto-built design matrix inside results/mle/
DESIGN_TXT = CUSTOM_DESIGN if CUSTOM_DESIGN else os.path.join(MLE_DIR, "design_matrix.txt")

# MAGeCK Flute and Output Directory Defined
OUT_DIR   = "results/plots"
PROJ_NAME = config["proj_name"]
FLUTE_DIR = f"{OUT_DIR}/MAGeCKFlute_{PROJ_NAME}"
FDR_THR = float(config["fdr_threshold"])
FDR_THR_STR = f"{FDR_THR:.2f}"
NORM_METHOD_STR = str(config["norm_method"]).lower()

##################################################################
##                          Rule All                            ##
##################################################################

rule all:
    input:
        expand("results/qc/fastqc/{sample}_R1_fastqc.html", sample=samples_table.index),
        *([expand("results/qc/fastqc/{sample}_R2_fastqc.html", sample=samples_table.index)]
          if run_mageck_paired else []),
        "results/qc/multiqc/multiqc_report.html",
        f"{COUNTS_PREFIX}.count.txt",
        f"{COUNTS_PREFIX}.countsummary.txt",
        *([f"{MLE_PREFIX}.gene_summary.txt"] if MLE_ENABLED else []),
        *([FLUTE_DIR] if MLE_ENABLED else []),
        *([f"{OUT_DIR}/beta_hist.png"] if MLE_ENABLED else []),
        *([f"{OUT_DIR}/beta_norm.png"] if MLE_ENABLED else []),
        *([f"{OUT_DIR}/volcano_diff_vs_neglog10FDR.png"] if MLE_ENABLED else []),
        *([f"{OUT_DIR}/custom_volcano_diff_vs_neglog10FDR.png"] if MLE_ENABLED else []),
        *([f"{OUT_DIR}/beta_scatter.png"] if MLE_ENABLED else []),
        *([f"{OUT_DIR}/beta_scatter_labeled.png"] if MLE_ENABLED else []),
        *([f"{OUT_DIR}/qc_gini.png"] if MLE_ENABLED else []),
        *([f"{OUT_DIR}/qc_zero_counts.png"] if MLE_ENABLED else []),
        *([f"{OUT_DIR}/qc_maprates.png"] if MLE_ENABLED else []),
        *([f"{OUT_DIR}/selection_table.norm_{NORM_METHOD_STR}.tsv"] if MLE_ENABLED else []),
        *([f"{OUT_DIR}/{PROJ_NAME}_sig_hits_FDR_{FDR_THR_STR}.tsv"] if MLE_ENABLED else []),
        *(["results/logs/stage_fastqs.cleaned"] if STAGE else [])

##################################################################
##                       Quality Control                        ##
##################################################################

if run_mageck_paired:
    rule fastqc_raw:
        input:
            unpack(fq_dict_from_sample)
        output:
            html1="results/qc/fastqc/{sample}_R1_fastqc.html",
            zip1 ="results/qc/fastqc/{sample}_R1_fastqc.zip",
            html2="results/qc/fastqc/{sample}_R2_fastqc.html",
            zip2 ="results/qc/fastqc/{sample}_R2_fastqc.zip"
        envmodules:
            config["fastqc"]
        threads: 4
        log: "results/logs/fastqc_{sample}.log"
        shell:
            """
            fastqc --threads {threads} -o results/qc/fastqc {input.fq1}
            fastqc --threads {threads} -o results/qc/fastqc {input.fq2}

            dir="results/qc/fastqc"
            bsename=$(basename {input.fq1} .gz); bsename=$(basename ${{bsename}} .fastq)
            mv ${{dir}}/${{bsename}}_fastqc.html {output.html1}
            mv ${{dir}}/${{bsename}}_fastqc.zip  {output.zip1}

            bsename=$(basename {input.fq2} .gz); bsename=$(basename ${{bsename}} .fastq)
            mv ${{dir}}/${{bsename}}_fastqc.html {output.html2}
            mv ${{dir}}/${{bsename}}_fastqc.zip  {output.zip2}
            """

    rule multiqc_raw:
        input:
            expand("results/qc/fastqc/{sample}_R1_fastqc.zip", sample=samples_table.index),
            expand("results/qc/fastqc/{sample}_R2_fastqc.zip", sample=samples_table.index)
        output:
            "results/qc/multiqc/multiqc_report.html"
        params:
            outdir="results/qc/multiqc"
        envmodules:
            config["multiqc"]
        threads: 2
        log: "results/logs/multiqc.log"
        shell:
            """
            multiqc results/qc/fastqc -o {params.outdir} 2> {log}
            """

else:
    rule fastqc_raw:
        input:
            unpack(lambda wc: {"fq1": samples_table.loc[wc.sample, "fastq1"]})
        output:
            html1="results/qc/fastqc/{sample}_R1_fastqc.html",
            zip1 ="results/qc/fastqc/{sample}_R1_fastqc.zip"
        envmodules:
            config["fastqc"]
        threads: 4
        log: "results/logs/fastqc_{sample}.log"
        shell:
            """
            fastqc --threads {threads} -o results/qc/fastqc {input.fq1}

            dir="results/qc/fastqc"
            bsename=$(basename {input.fq1} .gz); bsename=$(basename ${{bsename}} .fastq)
            mv ${{dir}}/${{bsename}}_fastqc.html {output.html1}
            mv ${{dir}}/${{bsename}}_fastqc.zip  {output.zip1}
            """

    rule multiqc_raw:
        input:
            expand("results/qc/fastqc/{sample}_R1_fastqc.zip", sample=samples_table.index)
        output:
            "results/qc/multiqc/multiqc_report.html"
        params:
            outdir="results/qc/multiqc"
        envmodules:
            config["multiqc"]
        threads: 2
        log: "results/logs/multiqc.log"
        shell:
            """
            multiqc results/qc/fastqc -o {params.outdir} 2> {log}
            """

##################################################################
##                         Stage FASTQs                         ##
##################################################################

if STAGE:
    STAGE_DIR = "results/staged_fastqs"

    # Per-sample staging
    rule stage_fastqs:
        input:
            unpack(fq_dict_from_sample)
        output:
            temporary_fq1 = temp(f"{STAGE_DIR}/{{sample}}_R1_staged.fastq.gz"),
            temporary_fq2 = temp(f"{STAGE_DIR}/{{sample}}_R2_staged.fastq.gz")
        threads: 2
        log:
            "results/logs/staged_{sample}.log"
        shell:
            """
            # R1 is required
            cp -f {input.fq1} {output.temporary_fq1}

            # R2 is optional (single-end friendly). If missing, create an empty placeholder
            if [ -n "{input.fq2}" ] && [ -e "{input.fq2}" ]; then
              cp -f {input.fq2} {output.temporary_fq2}
            else
              : > {output.temporary_fq2}
            fi
            """

    rule cleanup_staged_fastqs:
        input:
          f"{COUNTS_PREFIX}.countsummary.txt"
        output:
          touch("results/logs/stage_fastqs.cleaned")
        shell:
            """
            if [ -d "{STAGE_DIR}" ] && [ -z "$(ls -A {STAGE_DIR} 2>/dev/null)" ]; then
              rmdir "{STAGE_DIR}"
            fi
            """

##################################################################
##                         Mageck Count                         ##
##################################################################

rule mageck_count:
    input:
        mageck_input_files()
    output:
        txt=f"{COUNTS_PREFIX}.count.txt",
        summary=f"{COUNTS_PREFIX}.countsummary.txt"
    params:
        library=config["sgRNA_library"],
        labels=SAMPLE_LABELS,
        fastq1=(lambda wc: mageck_fastq_arg_r1()),
        fastq2=(lambda wc: f"--fastq-2 {mageck_fastq_arg_r2()}" if run_mageck_paired else ""),
        outprefix=COUNTS_PREFIX
    envmodules:
        config["mageck"],
        config["apptainer"]
    threads: 16
    log:
        "results/logs/mageck_count.log"
    shell:
        """
        # make sure directory is present and check names
        mkdir -p "$(dirname {params.outprefix})"
        echo "SingleEnd_Input: {params.fastq1}" >&2
        echo "PairedEnd_Input: {params.fastq2}" >&2
        echo "Sample_Labels: {params.labels}" >&2

        # run mageck count
        mageck count \
          -l "{params.library}" \
          --fastq {params.fastq1} \
          {params.fastq2} \
          --sample-label "{params.labels}" \
          -n "{params.outprefix}" \
          2> {log}
        """

##################################################################
##                    Build Design Matrix (auto)                ##
##################################################################

if MLE_ENABLED and not CUSTOM_DESIGN:
    rule build_design_matrix:
        input:
            config["samples_csv"]
        output:
            design = DESIGN_TXT
        threads: 1
        log:
            "results/logs/mageck_mle_design.log"
        run:
            import pandas as _pd, os, numpy as _np
            os.makedirs(os.path.dirname(output.design), exist_ok=True)

            # load fresh (don’t rely on global df mutations)
            df = _pd.read_csv(input[0])

            # required columns
            for col in ["sample", "fastq1", "fastq2", "include_mle", "factor"]:
                if col not in df.columns:
                    raise ValueError(f"Missing column '{col}' in samples.csv")

            # normalize include_mle to boolean
            df["include_mle"] = df["include_mle"].astype(str).str.lower().isin(["true","1","t","yes","y"])

            # keep only included rows
            df = df[df["include_mle"]].copy()

            # enforce order consistent with labels (samples_table.index)
            wanted = [s for s in samples_table.index if s in set(df["sample"])]
            df = df.set_index("sample").loc[wanted].reset_index()

            # factor normalization
            def _norm_factor(x):
                x = str(x).strip()
                return "none" if x.lower() in ["none","", "na","nan","null"] else x
            df["factor"] = df["factor"].map(_norm_factor)

            # design = group + baseline + one-hot factors (excluding "none")
            mat = _pd.DataFrame({"group": df["sample"], "baseline": 1})

            # collect unique factor values (excluding "none"), keep order of first appearance
            seen = []
            for v in df["factor"]:
                if v != "none" and v not in seen:
                    seen.append(v)

            for v in seen:
                mat[v] = (df["factor"] == v).astype(int)

            # write tsv
            mat.to_csv(output.design, sep="\t", index=False)

##################################################################
##                           MAGeCK MLE                         ##
##################################################################

if MLE_ENABLED:
    rule mageck_mle:
        input:
            counts = f"{COUNTS_PREFIX}.count.txt",
            design = DESIGN_TXT
        output:
            gene_summary = f"{MLE_PREFIX}.gene_summary.txt"
        params:
            prefix = MLE_PREFIX,
            ctrl = MLE_CTRL
        envmodules:
            config["mageck"],
            config["apptainer"]
        threads: 16
        log:
            "results/logs/mageck_mle.log"
        shell:
            """
            mkdir -p "$(dirname {params.prefix})"
            EXTRA=""
            if [ -n "{params.ctrl}" ]; then
              EXTRA="--control-sgrna {params.ctrl}"
            fi

            mageck mle \
              -k "{input.counts}" \
              -d "{input.design}" \
              -n "{params.prefix}" \
              --threads {threads} \
              $EXTRA \
              2> {log}
            """

##################################################################
##                  Gene & Count Summary Plots                  ##
##################################################################

if MLE_ENABLED:
    rule mle_analysis_plots:
        input:
            gene_summary = f"{MLE_PREFIX}.gene_summary.txt",
            count_summary = f"{COUNTS_PREFIX}.countsummary.txt",
            design = DESIGN_TXT
        output:
            mageckFlute = directory(FLUTE_DIR),
            hist_plot = f"{OUT_DIR}/beta_hist.png",
            norm_plot = f"{OUT_DIR}/beta_norm.png",
            scatter_plot = f"{OUT_DIR}/beta_scatter.png",
            scatter_plot_labeled = f"{OUT_DIR}/beta_scatter_labeled.png",
            qc_gini = f"{OUT_DIR}/qc_gini.png",
            qc_zero_counts = f"{OUT_DIR}/qc_zero_counts.png",
            qc_maprates = f"{OUT_DIR}/qc_maprates.png",
            volcano = f"{OUT_DIR}/volcano_diff_vs_neglog10FDR.png",
            cust_volcano = f"{OUT_DIR}/custom_volcano_diff_vs_neglog10FDR.png",
            selection_table = f"{OUT_DIR}/selection_table.norm_{NORM_METHOD_STR}.tsv",
            sig_hits = f"{OUT_DIR}/{PROJ_NAME}_sig_hits_FDR_{FDR_THR_STR}.tsv"
        params:
            out_dir = OUT_DIR,
            proj_name = PROJ_NAME,
            organism = config["organism"],
            norm_method = config["norm_method"],
            fdr_threshold = FDR_THR,
            y_cap = config["y_cap"],
            effect_thr = config["effect_thr"]
        envmodules:
            config["R"],
            config["bioconductor"]
        threads: 2
        log:
            "results/logs/mle_analysis_plots.log"
        shell:
            """
            Rscript scripts/mle_analysis.R \
              "{input.gene_summary}" "{input.count_summary}" "{input.design}" \
              "{params.out_dir}" "{params.proj_name}" "{params.organism}" \
              "{params.norm_method}" "{params.fdr_threshold}" \
              "{params.y_cap}" "{params.effect_thr}" \
              2> {log}
            """

