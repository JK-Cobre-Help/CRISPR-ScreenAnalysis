configfile: "config/config.yml"

##################################################################
##                         Author Info                          ##
##################################################################

# Author: Kevin A. Boyd
# Email: kevinboyd76@gmail.com
# GitHub: https://github.com/kevinboyd76
# Date Created: August 8, 2025
# Last Modified: August 8, 2025
# Version: 1.0.0
#
# Description: 
# 
#
#
#

##################################################################
##                  Specific Steps in Pipeline                  ##
##################################################################

#  Steps:
#  1) Quality control using FastQC (per read) and MultiQC (summary report)
#  2) 
#  3) 
#  4) 
#  5) 
#
# 
#  Outputs:
#    • FastQC and MultiQC HTML reports
#    • Mageck Counts
#    • Raw, CPM, and scaled BigWig files


##################################################################
##                    Define input functions                    ##
##################################################################

import os
import pandas as pd

# read the CSV file and set an index using the values in the "sample" column.
samples_table = pd.read_csv("config/samples.csv").set_index("sample", drop=False)

# fastq filename input function definition set to Python dictionary
def fq_dict_from_sample(wildcards):
  return {
    "fq1": samples_table.loc[wildcards.sample, "fastq1"],
    "fq2": samples_table.loc[wildcards.sample, "fastq2"]
  }

# Stage FASTQs
STAGE = config["stage_fastqs"]
STAGE_DIR = "results/staged_fastqs"
os.makedirs(STAGE_DIR, exist_ok=True)

# Set single end or paired end input for Mageck Count
run_mageck_paired = config["mageck_paired"]

# Set sample labels and counts prefix and attach the directory
SAMPLE_LABELS = ",".join(samples_table["sample"].tolist())
COUNTS_DIR = "results/counts"
os.makedirs(COUNTS_DIR, exist_ok=True)
COUNTS_PREFIX = os.path.join(COUNTS_DIR, config["counts_prefix"]) 

# functions to lookup file paths
def staged_name(sample, read):  # read: "R1" or "R2"
    return os.path.join(STAGE_DIR, f"{sample}_{read}_staged.fastq.gz")

def fq1_src(sample): return samples_table.loc[sample, "fastq1"]
def fq2_src(sample): return samples_table.loc[sample, "fastq2"]

def fq1_used(sample):
    """Path MAGeCK should read for R1 (staged if STAGE=True)."""
    return staged_name(sample, "R1") if STAGE else fq1_src(sample)

def fq2_used(sample):
    """Path MAGeCK should read for R2 (staged if STAGE=True)."""
    return staged_name(sample, "R2") if STAGE else fq2_src(sample)

def mageck_input_files():
    """
    Concrete list of files that mageck_count depends on.
    Ensures staging runs first when STAGE=True.
    """
    if run_mageck_paired:
        return [fq1_used(s) for s in samples_table.index] + \
               [fq2_used(s) for s in samples_table.index]
    else:
        return [fq1_used(s) for s in samples_table.index]

def mageck_fastq_arg_r1():
    """Space-separated list of R1 files for --fastq."""
    return " ".join(fq1_used(s) for s in samples_table.index)

def mageck_fastq_arg_r2():
    """Space-separated list of R2 files for --fastq-2."""
    return " ".join(fq2_used(s) for s in samples_table.index)

##################################################################
##                          Rule All                            ##
##################################################################

rule all:
    input:
        expand("results/qc/fastqc/{sample}_R1_fastqc.html", sample=samples_table.index),
        "results/qc/multiqc/multiqc_report.html",
        f"{COUNTS_PREFIX}.count.txt",
        f"{COUNTS_PREFIX}.countsummary.txt"
        

##################################################################
##                       Quality Control                        ##
##################################################################

# run fastqc on fastq.gz files before trimming
rule fastqc_raw:
    input:
        unpack(fq_dict_from_sample)
    output:
        html1="results/qc/fastqc/{sample}_R1_fastqc.html",
        zip1="results/qc/fastqc/{sample}_R1_fastqc.zip",
        html2="results/qc/fastqc/{sample}_R2_fastqc.html",
        zip2="results/qc/fastqc/{sample}_R2_fastqc.zip"
    envmodules:
        config["fastqc"]
    log: "results/logs/fastqc_{sample}.log"
    shell:
        """
        # Run FastQC with output directed to writable folder
        fastqc -o results/qc/fastqc {input.fq1}
        fastqc -o results/qc/fastqc {input.fq2}

        # Rename output files to match specified output paths
        dir="results/qc/fastqc"
        bsename=$(basename {input.fq1} .gz)
        bsename=$(basename ${{bsename}} .fastq)
        mv ${{dir}}/${{bsename}}_fastqc.html {output.html1}
        mv ${{dir}}/${{bsename}}_fastqc.zip {output.zip1}
        
        bsename=$(basename {input.fq2} .gz)
        bsename=$(basename ${{bsename}} .fastq)
        mv ${{dir}}/${{bsename}}_fastqc.html {output.html2}
        mv ${{dir}}/${{bsename}}_fastqc.zip {output.zip2}
        """

##################################################################
##                     Multiqc on Raw Fastqs                    ##
##################################################################

rule multiqc_raw:
    input:
        expand("results/qc/fastqc/{sample}_R1_fastqc.zip", sample=samples_table.index),
        expand("results/qc/fastqc/{sample}_R2_fastqc.zip", sample=samples_table.index)
    output:
        "results/qc/multiqc/multiqc_report.html"
    params:
        outdir="results/qc/multiqc"
    envmodules:
        config["multiqc"]
    log:
        "results/logs/multiqc.log"
    shell:
        """
        multiqc results/qc/fastqc -o {params.outdir} 2> {log}
        """

##################################################################
##                         Stage FASTQs                         ##
##################################################################

if STAGE:
    rule stage_fastqs:
        input:
            unpack(fq_dict_from_sample)
        output:
            temporary_fq1=temp("results/staged_fastqs/{sample}_R1_staged.fastq.gz"),
            temporary_fq2=temp("results/staged_fastqs/{sample}_R2_staged.fastq.gz")
        log:
            "results/logs/staged_{sample}.log"
        shell:
            """
            mkdir -p results/staged_fastqs
            cp -f {input.fq1} {output.temporary_fq1}
            cp -f {input.fq2} {output.temporary_fq2}
            """

##################################################################
##                         Mageck Count                         ##
##################################################################

rule mageck_count:
    input:
        mageck_input_files()
    output:
        txt=f"{COUNTS_PREFIX}.count.txt",
        summary=f"{COUNTS_PREFIX}.countsummary.txt"
    params:
        library=config["sgRNA_library"],
        labels=SAMPLE_LABELS,
        fastq1=(lambda wc: mageck_fastq_arg_r1()),
        fastq2=(lambda wc: f"--fastq-2 {mageck_fastq_arg_r2()}" if run_mageck_paired else ""),
        outprefix=COUNTS_PREFIX
    envmodules:
        config["mageck"],
        config["apptainer"]
    log:
        "results/logs/mageck_count.log"
    shell:
        """
        # make sure directory is present and check names
        mkdir -p "$(dirname {params.outprefix})"
        echo "SingleEnd_Input: {params.fastq1}" >&2
        echo "PairedEnd_Input: {params.fastq2}" >&2
        echo "Sample_Labels: {params.labels}" >&2

        # run mageck count
        mageck count \
          -l "{params.library}" \
          --fastq {params.fastq1} \
          {params.fastq2} \
          --sample-label "{params.labels}" \
          -n "{params.outprefix}" \
          2> {log}
        """

##################################################################
##                    Build Design Matrix (MLE)                 ##
##################################################################

rule build_design_matrix:
    input:
        config["samples_csv"]
    output:
        design = "results/mle/design_matrix.txt"
    params:
        include_col = "include_mle",   # change here if you prefer another name
        baseline    = "baseline"
    log:
        "results/logs/mageck_mle_design.log"
    run:
        # pandas and os are already imported at top; no need to re-import
        os.makedirs("results/mle", exist_ok=True)

        df = pd.read_csv(input[0])

        # sanity checks
        for required in ["sample", params.include_col]:
            if required not in df.columns:
                raise ValueError(f"Missing column '{required}' in samples.csv")

        # auto-detect factor columns: everything not in core columns
        core = {"sample", "fastq1", "fastq2", params.include_col}
        factor_cols = [c for c in df.columns if c not in core]
        if not factor_cols:
            raise ValueError("No factor columns found in samples.csv (need 0/1 columns for each factor).")

        # robust include parsing: accept 1/0, true/false, yes/no, y/n (case-insensitive)
        incl = df[params.include_col].astype(str).str.strip().str.lower()
        df = df[incl.isin({"1","true","t","yes","y"})]

        # enforce order consistent with labels / counts
        order = list(samples_table.index)
        df = df.set_index("sample").loc[[s for s in order if s in df.index]].reset_index()

        # coerce factors to int 0/1
        for f in factor_cols:
            df[f] = pd.to_numeric(df[f], errors="coerce").fillna(0).astype(int)

        # confirm all groups exist in counts labels
        label_set = set(samples_table.index)
        missing_in_counts = [s for s in df["sample"] if s not in label_set]
        if missing_in_counts:
            raise ValueError(f"Samples in design not present in counts labels: {missing_in_counts}")

        # build matrix: group + baseline + factors
        mat = pd.DataFrame({"group": df["sample"]})
        mat[params.baseline] = 1
        for f in factor_cols:
            mat[f] = df[f]

        mat.to_csv(output.design, sep="\t", index=False)

##################################################################
##                           MAGeCK MLE                         ##
##################################################################

rule mageck_mle:
    input:
        counts = f"{COUNTS_PREFIX}.count.txt",
        design = rules.build_design_matrix.output.design  # ensures dependency
    output:
        gene_summary = f"{config.get('mle_prefix','results/mle/mle')}.gene_summary.txt"
    params:
        prefix  = config.get("mle_prefix", "results/mle/mle"),
        ctrl    = config.get("mle_control_sgrna", "").strip(),
        threads = 4
    envmodules:
        config["mageck"]
    log:
        "results/logs/mageck_mle.log"
    shell:
        r"""
        mkdir -p "$(dirname "{params.prefix}")"
        EXTRA_CTRL=""
        if [ -n "{params.ctrl}" ]; then
          EXTRA_CTRL="--control-sgrna {params.ctrl}"
        fi

        mageck mle \
          -k "{input.counts}" \
          -d "{input.design}" \
          --threads {params.threads} \
          -n "{params.prefix}" \
          ${EXTRA_CTRL} \
          2> {log}
        """
